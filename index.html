<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>H·ªçc Ngo·∫°i Ng·ªØ AI</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap');
  :root{
    --bg-sky:#a7e0ff; --bg-grass:#b4f8c8; --primary:#fbe7c6; --secondary:#ffd6a5; --accent: #84a9ff;
    --danger:#ff8a80; --ok:#b9f6ca; --text:#3d2a1f; --panel:#ffffffee; --card-bg: #fff;
    --shadow-color: #00000020; --sidebar-bg: #fdfaf4; --disabled: #dcdcdc;
  }
  *{box-sizing:border-box;margin:0;padding:0; font-family:'Quicksand', sans-serif;}
  body{
    background:linear-gradient(135deg, var(--bg-sky), var(--bg-grass));
    color:var(--text); min-height:100vh;
    display:flex; overflow: hidden;
  }

  /* --- B·ªê C·ª§C CH√çNH --- */
  #sidebar{
    width: 280px; flex-shrink: 0; background: var(--sidebar-bg);
    padding: 1.5rem; display: flex; flex-direction: column;
    box-shadow: 4px 0 20px var(--shadow-color); z-index: 10;
    transition: transform 0.3s ease-in-out;
  }
  #main-content{ flex: 1; position: relative; }
  
  @media (max-width: 768px) {
    #sidebar { position: absolute; transform: translateX(-100%); }
    #sidebar.open { transform: translateX(0); }
    #menu-toggle {
      display: block; position: fixed; top: 1rem; left: 1rem; z-index: 1000;
      background: var(--panel); border-radius: 50%; width: 50px; height: 50px;
      border: none; font-size: 1.5rem; box-shadow: 0 4px 10px var(--shadow-color);
    }
  }

  /* --- COMPONENTS --- */
  .sidebar-header { text-align: center; margin-bottom: 2rem;}
  .sidebar-header h2 { font-size: 1.8rem; }
  .sidebar-hud { background: #ffffffaa; border-radius: 16px; padding: 1rem; margin-bottom: 1.5rem; }
  .hud-item { margin-bottom: 0.8rem; font-size: 1.2rem; font-weight: 700; }
  #lives-display { font-size: 1.5rem; }
  .sidebar-nav { margin-top: auto; display: flex; flex-direction: column; gap: 0.5rem; }
  .sidebar-hud, .game-controls { display: none; }
  .game-active .sidebar-hud, .game-active .game-controls { display: block; }
  
  /* --- M√ÄN H√åNH (SCREEN) --- */
  .screen{
    position:absolute; inset:0; padding:clamp(1rem, 5vh, 2rem);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    transition: opacity .35s ease-in-out, transform .35s ease-in-out;
    gap:clamp(0.8rem, 2vh, 1.5rem); text-align:center;
    overflow-y: auto;
  }
  .hidden{ opacity:0; transform:scale(.97); pointer-events:none; }
  
  h1{font-size:clamp(32px, 8vw, 52px);}
  h2{font-size:clamp(24px, 6vw, 40px);}
  p{font-size:clamp(16px, 4vw, 22px);}
  .btn{
    width: 100%; padding:.8em 1.5em; border:none; border-radius:12px;
    background:var(--primary); font-weight:700; cursor:pointer;
    box-shadow: 0 4px var(--shadow-color);
    margin:.3em 0; transition: all .1s ease-out;
    font-size: clamp(16px, 4vw, 20px);
  }
  .btn:hover{ transform:translateY(-2px); box-shadow:0 6px 12px var(--shadow-color); }
  .btn:active{ transform:translateY(1px); box-shadow:0 2px 4px var(--shadow-color); }
  .btn.secondary{background:var(--secondary);}
  .btn.accent{background:var(--accent); color:#fff;}
  .btn.danger{background:var(--danger); color:#fff;}
  .btn.ok{background:var(--ok);}
  .btn.small { padding: 0.6em 1em; font-size: clamp(14px, 3.5vw, 16px); width: auto; }
  .btn[disabled]{opacity:.5; cursor:not-allowed; transform:none; box-shadow:0 2px 4px var(--shadow-color);}
  input, textarea{
    width:min(520px, 90%); padding:.8em; font-size:1.05em; text-align:center;
    border:3px solid var(--secondary); border-radius:14px; background:var(--card-bg); margin-bottom: 1rem;
  }

  /* --- Set Selection & AI Generation --- */
  #set-selection-screen .content-wrapper { display: flex; flex-direction: column; gap: 2rem; width: 100%; max-width: 900px; }
  .set-container { background: var(--panel); padding: 1.5rem; border-radius: 16px; }
  .ai-generator input { width: 100%; }
  .ai-generator .btn-group { display: flex; gap: 1rem; }
  #saved-sets-list { list-style: none; padding: 0; max-height: 40vh; overflow-y: auto; }
  #saved-sets-list li { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem; border-bottom: 1px solid #eee; }
  #saved-sets-list li:last-child { border-bottom: none; }
  
  /* --- GAME SCREEN --- */
  #game-content { width:100%; height: 100%; display:flex; flex-direction: column; align-items:center; justify-content:center; gap:1.5rem; padding: 1rem; }
  .game-panel {
    background: var(--panel); border-radius: 24px; padding: clamp(1rem, 2vw, 2rem);
    box-shadow: 0 8px 25px var(--shadow-color); display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 1.5rem; width: 100%;
  }
  .question-panel { flex: 1; max-height: 50%; }
  .answer-panel { flex: 1; max-height: 50%; overflow-y: auto; }
  .question-panel img { max-width: 100%; max-height: 35vh; object-fit: contain; border-radius: 16px; }
  #listen-again-btn { font-size: 3em; background: none; border: none; cursor: pointer; }
  .choices-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:.8rem; width:100%; }
  
  /* --- FILL IN BLANK MODE --- */
  #word-slots{display:flex; flex-wrap:wrap; gap:.5rem; justify-content:center; margin-bottom: 1rem; }
  .slot{
    width:clamp(40px, 10vw, 55px); height:clamp(50px, 12vw, 65px); border:3px dashed #bcd; border-radius:10px;
    background:#f6fbff; display:flex; align-items:center; justify-content:center;
    font-size: clamp(1.5em, 5vw, 2em); font-weight:700;
  }
  .slot.filled{border-style:solid; background:var(--card-bg);} .slot.space{border:none; background:transparent; width:1ch;}
  #letter-bank{display:flex; flex-wrap:wrap; gap:.5rem; justify-content:center; max-width: 100%;}
  .letter-tile{
    width:clamp(45px, 11vw, 60px); height:clamp(45px, 11vw, 60px); border-radius:12px; background:#ffe9a8;
    box-shadow: 0 4px #e1c06a; font-weight:700; cursor:pointer;
    display:flex; align-items:center; justify-content:center; font-size:clamp(1.2em, 4vw, 1.8em);
    transition: all .15s;
  }
  .letter-tile:hover { transform:scale(1.05); } .letter-tile.hidden{ visibility:hidden; }

  /* --- TRANSLATOR SCREEN --- */
  #translator-screen { gap: 1rem; width: 100%; }
  #translator-container { display: flex; flex-direction: column; gap: 1rem; width: 100%; max-width: 700px; height: 100%; }
  .lang-selector { display: flex; justify-content: center; align-items: center; gap: 1rem; }
  #swap-lang-btn { font-size: 1.5rem; }
  #translator-input { height: 35%; resize: none; text-align: left; }
  #translator-output { min-height: 35%; background: #f0f0f0; border-radius: 14px; padding: .8em; text-align: left; overflow-y: auto; }

  /* --- MODALS --- */
  .modal-overlay{ background:#00000088; z-index: 100; }
  .modal-box{ background:var(--card-bg); padding:1.5rem; border-radius:16px; width:min(500px, 90%); animation: pop-in .3s ease-out; }
  @keyframes pop-in { from { transform:scale(0.9); opacity:0; } to { transform:scale(1); opacity:1; } }
  .loading-indicator { text-align: center; }
  .loader { width: 48px; height: 48px; border: 5px solid #FFF; border-bottom-color: var(--secondary); border-radius: 50%; display: inline-block; animation: rotation 1s linear infinite; }
  @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

</style>
</head>
<body>

<button id="menu-toggle" style="display: none;">‚ò∞</button>
<div id="sidebar">
    <div class="sidebar-header">
        <h2>H·ªçc AI</h2>
        <p>N√¢ng tr√¨nh ngo·∫°i ng·ªØ</p>
    </div>
    <div class="sidebar-hud">
        <div class="hud-item" id="score-display">üíØ ƒêi·ªÉm: 0</div>
        <div class="hud-item" id="lives-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    </div>
    <nav class="sidebar-nav">
        <div class="game-controls">
             <button id="home-btn" class="btn">üè† V·ªÅ Menu</button>
        </div>
        <button id="nav-learn-btn" class="btn accent">üìö H·ªçc T·ª´ V·ª±ng</button>
        <button id="nav-translate-btn" class="btn secondary">üåê D·ªãch Thu·∫≠t</button>
        <button id="settings-btn" class="btn secondary">‚öôÔ∏è C√†i ƒë·∫∑t</button>
    </nav>
</div>

<main id="main-content">
  <!-- START -->
  <div id="start-screen" class="screen">
    <h1>H·ªçc Ngo·∫°i Ng·ªØ AI</h1>
    <p>Nh·∫≠p t√™n c·ªßa b·∫°n ƒë·ªÉ b·∫Øt ƒë·∫ßu!</p>
    <input id="player-name-input" maxlength="20" placeholder="T√™n c·ªßa b·∫°n ‚úèÔ∏è"/>
    <button id="start-btn" class="btn ok">B·∫Øt ƒë·∫ßu ‚ñ∂Ô∏è</button>
  </div>
  
  <!-- SET SELECTION -->
  <div id="set-selection-screen" class="screen hidden">
    <h2>Ch·ªçn ho·∫∑c t·∫°o ch·ªß ƒë·ªÅ ƒë·ªÉ h·ªçc</h2>
    <div class="content-wrapper">
        <div class="set-container ai-generator">
            <h3>T·∫°o b·ªô t·ª´ v·ª±ng b·∫±ng AI ‚ú®</h3>
            <p>Nh·∫≠p m·ªôt ch·ªß ƒë·ªÅ (vd: v≈© tr·ª•, ƒë·ªông v·∫≠t bi·ªÉn, Gi√°ng sinh...)</p>
            <input id="ai-topic-input" placeholder="Ch·ªß ƒë·ªÅ b·∫°n mu·ªën h·ªçc..."/>
            <div class="btn-group">
                <button id="ai-generate-btn" class="btn accent">T·∫°o Ngay!</button>
            </div>
        </div>
        <div class="set-container">
            <h3>B·ªô t·ª´ ƒë√£ l∆∞u & c√≥ s·∫µn</h3>
            <ul id="saved-sets-list">
                <!-- D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c ch√®n b·ªüi JS -->
            </ul>
        </div>
    </div>
  </div>

  <!-- PRACTICE TYPE SELECTION -->
  <div id="practice-type-screen" class="screen hidden">
      <h2 id="practice-set-title"></h2>
      <p>B·∫°n mu·ªën luy·ªán t·∫≠p g√¨?</p>
      <div style="width: min(400px, 90%)">
          <button class="btn ok" data-type="word">T·ª´ V·ª±ng ƒê∆°n L·∫ª</button>
          <button class="btn ok" data-type="sentence">M·∫´u C√¢u Ho√†n Ch·ªânh</button>
          <button class="btn" id="practice-type-back-btn">‚¨ÖÔ∏è ƒê·ªïi ch·ªß ƒë·ªÅ</button>
      </div>
  </div>

  <!-- MENU -->
  <div id="menu-screen" class="screen hidden">
    <h2 id="menu-title">Ch·ªçn ch·∫ø ƒë·ªô ch∆°i</h2>
    <div id="game-modes-grid" class="selection-grid" style="max-width: 800px;"></div>
    <button id="menu-back-btn" class="btn">‚¨ÖÔ∏è Quay l·∫°i</button>
  </div>

  <!-- GAME -->
  <div id="game-screen" class="screen hidden">
    <div id="game-content">
        <div id="question-panel" class="game-panel question-panel">
            <!-- N·ªôi dung c√¢u h·ªèi (·∫£nh, text, √¢m thanh) s·∫Ω ƒë∆∞·ª£c ch√®n v√†o ƒë√¢y -->
        </div>
        <div id="answer-panel" class="game-panel answer-panel">
            <!-- C√°c l·ª±a ch·ªçn tr·∫£ l·ªùi ho·∫∑c khu v·ª±c ƒëi·ªÅn t·ª´ s·∫Ω ·ªü ƒë√¢y -->
        </div>
    </div>
  </div>

  <!-- TRANSLATOR -->
  <div id="translator-screen" class="screen hidden">
      <h2>AI D·ªãch Thu·∫≠t</h2>
      <div id="translator-container">
          <div class="lang-selector">
              <select id="source-lang-select" class="btn small"></select>
              <button id="swap-lang-btn" class="btn small">‚áå</button>
              <select id="target-lang-select" class="btn small"></select>
          </div>
          <textarea id="translator-input" placeholder="Nh·∫≠p vƒÉn b·∫£n c·∫ßn d·ªãch..."></textarea>
          <button id="translate-btn" class="btn accent">D·ªãch</button>
          <div id="translator-output">B·∫£n d·ªãch s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y...</div>
      </div>
  </div>

  <!-- END -->
  <div id="end-screen" class="screen hidden">
    <h2>K·∫øt th√∫c!</h2>
    <p>ƒêi·ªÉm cu·ªëi c√πng c·ªßa b·∫°n:</p>
    <h1 id="final-score">0</h1>
    <button id="restart-btn" class="btn ok">Ch∆°i l·∫°i ch·ªß ƒë·ªÅ n√†y üîÑ</button>
    <button id="to-menu-btn" class="btn">üè† V·ªÅ Menu ch√≠nh</button>
  </div>

  <!-- MODALS -->
  <div id="loading-modal" class="screen hidden modal-overlay">
      <div class="loading-indicator">
          <div class="loader"></div>
          <p id="loading-text" style="color: white; margin-top: 1rem; font-size: 1.2em;">ƒêang t·∫£i...</p>
      </div>
  </div>
  <div id="save-set-modal" class="screen hidden modal-overlay">
      <div class="modal-box">
          <h2 id="save-set-title">L∆∞u b·ªô t·ª´ v·ª±ng?</h2>
          <p>B·∫°n c√≥ mu·ªën l∆∞u l·∫°i b·ªô t·ª´ v·ª±ng v·ªÅ ch·ªß ƒë·ªÅ "<b id="save-set-topic"></b>" ƒë·ªÉ h·ªçc l·∫°i sau kh√¥ng?</p>
          <div style="display: flex; gap: 1rem; margin-top: 1rem;">
              <button id="confirm-save-btn" class="btn ok">L∆∞u l·∫°i</button>
              <button id="cancel-save-btn" class="btn secondary">Kh√¥ng, c·∫£m ∆°n</button>
          </div>
      </div>
  </div>
   <div id="settings-modal" class="screen hidden modal-overlay">
    <div class="modal-box">
      <h2>T√πy ch·ªânh</h2>
       <label>Gi·ªçng ƒë·ªçc:
          <select id="voice-select"><option>ƒêang t·∫£i...</option></select>
        </label>
      <button id="save-settings-btn" class="btn ok">ƒê√≥ng</button>
    </div>
  </div>

</main>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { VOCABULARY_SETS as initialSets } from './vocabulary.js';

    // --- Firebase Config ---
    // IMPORTANT: Replace with your actual Firebase configuration
	const firebaseConfig = {

	¬† apiKey: "AIzaSyCCbca7N4rSeGGDs8Xr2yjEBgWn7ihOn-U",

	¬† authDomain: "hoccungtam.firebaseapp.com",

	¬† projectId: "hoccungtam",

	¬† storageBucket: "hoccungtam.firebasestorage.app",

	¬† messagingSenderId: "827609819388",

	¬† appId: "1:827609819388:web:67cfd286094e688ff28f79",

	¬† measurementId: "G-L7ZDXPNMPM"

	};
    
    // --- App Initialization ---
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    const $ = id => document.getElementById(id);

    const allScreens = document.querySelectorAll('.screen');
    const sidebar = $('sidebar');
    const menuToggle = $('menu-toggle');
    
    let state = {
        player: '', score: 0, lives: 3,
        userId: null,
        currentSet: null,
        currentSetId: null,
        currentItems: [],
        currentItem: null,
        practiceType: 'word', // 'word' or 'sentence'
        gameMode: null,
        canInteract: true,
        tempAiSet: null,
    };
    
    let settings = { voiceURI:'auto' };
    let voices = [];
    const tts = window.speechSynthesis;
    const availableLangs = {
        'vi': 'Ti·∫øng Vi·ªát üáªüá≥',
        'en': 'Ti·∫øng Anh üá¨üáß',
        'ko': 'Ti·∫øng H√†n üá∞üá∑'
    };
    
    // --- CORE APP LOGIC ---

    function showScreen(screenId) {
        allScreens.forEach(s => s.id === screenId ? s.classList.remove('hidden') : s.classList.add('hidden'));
        if (['game', 'end'].includes(screenId)) sidebar.classList.add('game-active');
        else if (!screenId.includes('modal')) sidebar.classList.remove('game-active');
        sidebar.classList.remove('open');
    }

    function showLoading(text = "ƒêang x·ª≠ l√Ω...") {
        $('loading-text').textContent = text;
        $('loading-modal').classList.remove('hidden');
    }

    function hideLoading() {
        $('loading-modal').classList.add('hidden');
    }

    async function main() {
        showScreen('start-screen');
        try {
            await signInAnonymously(auth);
            state.userId = auth.currentUser.uid;
            console.log("Signed in with UID:", state.userId);
            setupFirestoreListener();
            populateVoices();
            if (tts.onvoiceschanged !== undefined) tts.onvoiceschanged = populateVoices;
        } catch(e) {
            console.error("Auth Error:", e);
            alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß. Vui l√≤ng t·∫£i l·∫°i trang.");
        }
    }

    function setupFirestoreListener() {
        const userDocRef = doc(db, "users", state.userId);
        onSnapshot(userDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const userData = docSnap.data();
                renderSavedSets(userData.savedSets || {});
            } else {
                // First time user, create their document with initial sets
                const initialUserSets = {};
                Object.keys(initialSets).forEach(key => {
                    initialUserSets[key] = {
                        name: initialSets[key].name,
                        items: initialSets[key].words
                    };
                });
                setDoc(userDocRef, { savedSets: initialUserSets });
            }
        });
    }

    function renderSavedSets(sets) {
        const list = $('saved-sets-list');
        list.innerHTML = '';
        if (Object.keys(sets).length === 0) {
            list.innerHTML = '<li>Ch∆∞a c√≥ b·ªô t·ª´ n√†o ƒë∆∞·ª£c l∆∞u.</li>';
            return;
        }
        for (const setId in sets) {
            const set = sets[setId];
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${set.name}</span>
                <div>
                    <button class="btn small ok" data-set-id="${setId}">H·ªçc</button>
                    <button class="btn small danger" data-delete-id="${setId}">X√≥a</button>
                </div>
            `;
            list.appendChild(li);
        }
    }
    
    // --- EVENT LISTENERS ---

    $('start-btn').onclick = () => {
        const name = $('player-name-input').value.trim();
        if (name.length < 2) return alert('T√™n c·∫ßn c√≥ √≠t nh·∫•t 2 k√Ω t·ª±!');
        state.player = name;
        showScreen('set-selection-screen');
    };

    $('ai-generate-btn').onclick = async () => {
        const topic = $('ai-topic-input').value.trim();
        if (topic.length < 3) return alert("Ch·ªß ƒë·ªÅ c·∫ßn c√≥ √≠t nh·∫•t 3 k√Ω t·ª±.");
        
        showLoading("AI ƒëang s√°ng t·∫°o b·ªô t·ª´ v·ª±ng...");
        try {
            const response = await fetch('/.netlify/functions/generate-set', {
                method: 'POST',
                body: JSON.stringify({ topic })
            });
            if (!response.ok) throw new Error('Network response was not ok');
            const data = await response.json();
            
            // S·ª¨A L·ªñI: L·ªçc v√† l√†m s·∫°ch d·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ AI ƒë·ªÉ lo·∫°i b·ªè c√°c m·ª•c kh√¥ng h·ª£p l·ªá
            const cleanedItems = data.items.filter(item => item && item.vi && item.en && item.ko);
            
            state.tempAiSet = {
                name: `AI: ${topic}`,
                items: cleanedItems,
            };

            $('save-set-topic').textContent = topic;
            showScreen('save-set-modal');

        } catch (error) {
            console.error("AI Generation Error:", error);
            alert("R·∫•t ti·∫øc, AI kh√¥ng th·ªÉ t·∫°o b·ªô t·ª´ v·ª±ng l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.");
        } finally {
            hideLoading();
        }
    };
    
    $('confirm-save-btn').onclick = async () => {
        if (!state.tempAiSet) return;
        showLoading("ƒêang l∆∞u...");
        const newSetId = `ai_${Date.now()}`;
        const userDocRef = doc(db, "users", state.userId);
        await updateDoc(userDocRef, {
            [`savedSets.${newSetId}`]: state.tempAiSet
        });
        hideLoading();
        startPractice(newSetId, state.tempAiSet);
        state.tempAiSet = null;
    };

    $('cancel-save-btn').onclick = () => {
        if (!state.tempAiSet) return;
        const tempSetId = `temp_${Date.now()}`;
        startPractice(tempSetId, state.tempAiSet);
        state.tempAiSet = null;
    };

    $('saved-sets-list').onclick = async (e) => {
        const setId = e.target.dataset.setId;
        const deleteId = e.target.dataset.deleteId;

        if (setId) {
            const userDocRef = doc(db, "users", state.userId);
            const docSnap = await getDoc(userDocRef);
            if (docSnap.exists()) {
                const set = docSnap.data().savedSets[setId];
                if (set) {
                    startPractice(setId, set);
                }
            }
        } else if (deleteId) {
            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b·ªô t·ª´ v·ª±ng n√†y kh√¥ng?`)) {
                const userDocRef = doc(db, "users", state.userId);
                await updateDoc(userDocRef, {
                    [`savedSets.${deleteId}`]: deleteField() // Firestore way to delete a map field
                });
                alert("ƒê√£ x√≥a!");
            }
        }
    };

    function startPractice(setId, set) {
        state.currentSetId = setId;
        state.currentSet = set;
        
        const hasWords = set.items.some(i => i.type === 'word');
        const hasSentences = set.items.some(i => i.type === 'sentence');

        $('practice-type-screen').querySelector('[data-type="word"]').style.display = hasWords ? 'block' : 'none';
        $('practice-type-screen').querySelector('[data-type="sentence"]').style.display = hasSentences ? 'block' : 'none';

        $('practice-set-title').textContent = `Ch·ªß ƒë·ªÅ: ${set.name}`;
        showScreen('practice-type-screen');
    }

    $('practice-type-screen').onclick = (e) => {
        if (e.target.dataset.type) {
            state.practiceType = e.target.dataset.type;
            populateGameModes();
            showScreen('menu-screen');
        } else if (e.target.id === 'practice-type-back-btn') {
            showScreen('set-selection-screen');
        }
    };
    
    $('menu-back-btn').onclick = () => showScreen('practice-type-screen');
    
    function populateGameModes() {
        const grid = $('game-modes-grid');
        grid.innerHTML = '';
        $('menu-title').textContent = `Luy·ªán t·∫≠p: ${state.practiceType === 'word' ? 'T·ª´ V·ª±ng' : 'M·∫´u C√¢u'}`;
        
        const modes = [
            { id: 'quiz-image', name: 'Xem h√¨nh ‚Üí ch·ªçn nghƒ©a', types: ['word'] },
            { id: 'listen-image', name: 'Nghe ‚Üí ch·ªçn h√¨nh', types: ['word'] },
            { id: 'fill-letter', name: 'ƒêi·ªÅn ch·ªØ c√°i c√≤n thi·∫øu', types: ['word'] },
            { id: 'fill-word', name: 'ƒêi·ªÅn t·ª´ v√†o c√¢u', types: ['sentence'] },
        ];

        modes.filter(m => m.types.includes(state.practiceType)).forEach(mode => {
            const btn = document.createElement('button');
            btn.className = 'btn ok';
            btn.textContent = mode.name;
            btn.onclick = () => startGame(mode.id);
            grid.appendChild(btn);
        });
    }

    function startGame(modeId) {
        state.gameMode = modeId;
        state.score = 0;
        state.lives = 3;
        state.currentItems = state.currentSet.items.filter(i => i.type === state.practiceType);
        
        // Shuffle items for variety
        state.currentItems.sort(() => 0.5 - Math.random());

        updateHUD();
        showScreen('game-screen');
        nextTurn();
    }

    function updateHUD() {
        $('score-display').textContent = `üíØ ƒêi·ªÉm: ${state.score}`;
        $('lives-display').innerHTML = '‚ù§Ô∏è'.repeat(state.lives);
    }
    
    async function nextTurn() {
        if (state.lives <= 0 || state.currentItems.length === 0) {
            return endGame();
        }
        state.canInteract = true;

        // Take the next item from the list
        state.currentItem = state.currentItems.pop();

        const questionPanel = $('question-panel');
        const answerPanel = $('answer-panel');
        questionPanel.innerHTML = '';
        answerPanel.innerHTML = '';

        // Render game based on mode
        switch(state.gameMode) {
            case 'quiz-image':
                await renderQuizImage();
                break;
            case 'listen-image':
                await renderListenImage();
                break;
            case 'fill-letter':
                renderFillLetter();
                break;
            case 'fill-word':
                renderFillWord();
                break;
        }
    }
    
    async function getDisplayImage(item) {
        showLoading("AI ƒëang v·∫Ω ·∫£nh...");
        try {
            const res = await fetch('/.netlify/functions/get-image', {
                method: 'POST',
                body: JSON.stringify({ item })
            });
            if (!res.ok) throw new Error("Image fetch failed");
            const data = await res.json();
            return data.imageUrl;
        } catch(e) {
            console.error(e);
            return `https://placehold.co/600x400/eef5ff/6b7b93?text=${encodeURIComponent(item.en)}`;
        } finally {
            hideLoading();
        }
    }
    
    async function renderQuizImage() {
        const item = state.currentItem;
        const questionPanel = $('question-panel');
        const answerPanel = $('answer-panel');

        const imageUrl = await getDisplayImage(item);
        questionPanel.innerHTML = `<img src="${imageUrl}" alt="${item.en}">`;

        // Create choices
        const choices = generateChoices(item, 3).map(choice => choice.vi);
        const choicesGrid = document.createElement('div');
        choicesGrid.className = 'choices-grid';
        choices.forEach(choiceText => {
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.textContent = choiceText;
            btn.onclick = (e) => checkAnswer(choiceText === item.vi, e.target);
            choicesGrid.appendChild(btn);
        });
        answerPanel.appendChild(choicesGrid);
    }
    
    async function renderListenImage() {
        const item = state.currentItem;
        const questionPanel = $('question-panel');
        const answerPanel = $('answer-panel');
        
        questionPanel.innerHTML = `<button id="listen-again-btn">üîä</button>`;
        $('listen-again-btn').onclick = () => speak(item.vi, 'vi');

        const choices = generateChoices(item, 3);
        const choicesGrid = document.createElement('div');
        choicesGrid.className = 'choices-grid';

        const imagePromises = choices.map(choice => getDisplayImage(choice));
        const imageUrls = await Promise.all(imagePromises);

        choices.forEach((choice, index) => {
            const imgContainer = document.createElement('div');
            imgContainer.className = 'img-choice';
            imgContainer.innerHTML = `<img src="${imageUrls[index]}" alt="${choice.en}" style="width: 100%; height: 150px; object-fit: cover; border-radius: 12px; cursor: pointer;">`;
            imgContainer.onclick = (e) => checkAnswer(choice.vi === item.vi, e.currentTarget);
            choicesGrid.appendChild(imgContainer);
        });
        answerPanel.appendChild(choicesGrid);
        speak(item.vi, 'vi');
    }

    function renderFillLetter() {
      // Logic for fill the letter game mode
      const item = state.currentItem;
      const questionPanel = $('question-panel');
      const answerPanel = $('answer-panel');
      const word = item.vi.replace(/ /g, '');
      const chars = [...word];
      
      const missingCount = Math.max(1, Math.floor(chars.length * 0.4));
      const missingIndices = new Set();
      while(missingIndices.size < missingCount) {
        missingIndices.add(Math.floor(Math.random() * chars.length));
      }

      questionPanel.innerHTML = `<p style="font-size: 1.5em; letter-spacing: 0.2em;">${item.en}</p>`;

      const slots = document.createElement('div');
      slots.id = 'word-slots';
      const lettersToFind = [];
      chars.forEach((char, i) => {
        const slot = document.createElement('div');
        slot.className = 'slot';
        if (missingIndices.has(i)) {
          lettersToFind.push(char);
        } else {
          slot.textContent = char;
          slot.classList.add('filled');
        }
        slots.appendChild(slot);
      });
      answerPanel.appendChild(slots);
      
      const letterBank = document.createElement('div');
      letterBank.id = 'letter-bank';
      const bankChars = [...lettersToFind, ...generateRandomChars(6, lettersToFind)].sort(() => 0.5 - Math.random());
      bankChars.forEach(char => {
        const tile = document.createElement('div');
        tile.className = 'letter-tile';
        tile.textContent = char;
        tile.onclick = () => placeLetter(tile);
        letterBank.appendChild(tile);
      });
      answerPanel.appendChild(letterBank);

      const submitBtn = document.createElement('button');
      submitBtn.id = "submit-word";
      submitBtn.className = "btn ok";
      submitBtn.textContent = "Ki·ªÉm tra";
      submitBtn.onclick = () => {
          const guess = [...slots.children].map(s => s.textContent).join('');
          checkAnswer(guess.toLowerCase() === word.toLowerCase(), submitBtn);
      };
      answerPanel.appendChild(submitBtn);
    }
    
    function renderFillWord() {
        const item = state.currentItem; // This is a sentence item
        const questionPanel = $('question-panel');
        const answerPanel = $('answer-panel');

        const parts = item.vi.split(/(\[.*?\])/).filter(p => p);
        const blankWord = parts.find(p => p.startsWith('[')).slice(1, -1);
        const sentenceHtml = parts.map(p => p.startsWith('[') ? '______' : `<span>${p}</span>`).join('');
        
        questionPanel.innerHTML = `
            <p style="font-size: 1.2em; margin-bottom: 1rem;">ƒêi·ªÅn t·ª´ c√≤n thi·∫øu:</p>
            <h3 style="font-size: 1.5em;">${sentenceHtml}</h3>
            <p style="font-size: 1.1em; color: #555; margin-top: 1rem;">(${item.en})</p>
        `;
        
        const otherWords = state.currentSet.items
            .filter(i => i.type === 'word' && i.vi !== blankWord)
            .sort(() => 0.5 - Math.random())
            .slice(0, 3)
            .map(w => w.vi);

        const choices = [blankWord, ...otherWords].sort(() => 0.5 - Math.random());
        const choicesGrid = document.createElement('div');
        choicesGrid.className = 'choices-grid';
        choices.forEach(choiceText => {
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.textContent = choiceText;
            btn.onclick = (e) => checkAnswer(choiceText === blankWord, e.target);
            choicesGrid.appendChild(btn);
        });
        answerPanel.appendChild(choicesGrid);
    }

    function checkAnswer(isCorrect, element) {
        if (!state.canInteract) return;
        state.canInteract = false;

        if (isCorrect) {
            state.score += 10;
            element.style.backgroundColor = 'var(--ok)';
        } else {
            state.lives -= 1;
            element.style.backgroundColor = 'var(--danger)';
        }
        updateHUD();
        setTimeout(nextTurn, 1500);
    }

    function generateChoices(correctItem, numWrong) {
        const allPossibleItems = state.currentSet.items.filter(i => i.type === state.practiceType && i.vi !== correctItem.vi);
        const wrongItems = allPossibleItems.sort(() => 0.5 - Math.random()).slice(0, numWrong);
        return [correctItem, ...wrongItems].sort(() => 0.5 - Math.random());
    }

    function placeLetter(tile) {
        const slots = [...document.querySelectorAll('#word-slots .slot')];
        const emptySlot = slots.find(s => !s.textContent);
        if(emptySlot) {
            emptySlot.textContent = tile.textContent;
            tile.classList.add('hidden');
        }
    }

    function generateRandomChars(count, exclude) {
        const alphabet = 'aƒÉ√¢bcdƒëe√™ghiklmno√¥∆°pqrstu∆∞vxy';
        const result = [];
        while(result.length < count) {
            const char = alphabet[Math.floor(Math.random() * alphabet.length)];
            if(!exclude.includes(char)) {
                result.push(char);
            }
        }
        return result;
    }

    function endGame() {
        $('final-score').textContent = state.score;
        showScreen('end-screen');
    }

    // --- Navigation & Other UI ---
    menuToggle.onclick = () => sidebar.classList.toggle('open');
    $('nav-learn-btn').onclick = () => showScreen('set-selection-screen');
    $('nav-translate-btn').onclick = () => {
        setupTranslator();
        showScreen('translator-screen');
    }
    $('settings-btn').onclick = () => showScreen('settings-modal');
    $('save-settings-btn').onclick = () => {
        settings.voiceURI = $('voice-select').value;
        showScreen('game-screen'); // Or whatever the previous screen was
    }
    $('home-btn').onclick = () => {
        if(confirm("B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t? Ti·∫øn tr√¨nh s·∫Ω kh√¥ng ƒë∆∞·ª£c l∆∞u.")) {
            showScreen('set-selection-screen');
        }
    };
    $('restart-btn').onclick = () => startGame(state.gameMode);
    $('to-menu-btn').onclick = () => showScreen('set-selection-screen');
    
    // --- Translator Logic ---
    function setupTranslator() {
        const sourceSelect = $('source-lang-select');
        const targetSelect = $('target-lang-select');
        sourceSelect.innerHTML = Object.entries(availableLangs).map(([code, name]) => `<option value="${code}">${name}</option>`).join('');
        targetSelect.innerHTML = sourceSelect.innerHTML;
        sourceSelect.value = 'vi';
        targetSelect.value = 'en';
    }
    $('swap-lang-btn').onclick = () => {
        const sourceSelect = $('source-lang-select');
        const targetSelect = $('target-lang-select');
        [sourceSelect.value, targetSelect.value] = [targetSelect.value, sourceSelect.value];
    };
    $('translate-btn').onclick = async () => {
        const text = $('translator-input').value.trim();
        const sourceLang = $('source-lang-select').value;
        const targetLang = $('target-lang-select').value;
        if (!text) return;

        showLoading("ƒêang d·ªãch...");
        try {
            const res = await fetch('/.netlify/functions/translate-text', {
                method: 'POST',
                body: JSON.stringify({ text, sourceLang, targetLang })
            });
            if (!res.ok) throw new Error('Translation failed');
            const data = await res.json();
            $('translator-output').textContent = data.translatedText;
        } catch (e) {
            console.error(e);
            $('translator-output').textContent = "ƒê√£ x·∫£y ra l·ªói khi d·ªãch.";
        } finally {
            hideLoading();
        }
    };

    // --- TTS Logic ---
    function populateVoices() {
      voices = tts.getVoices();
      const select = $('voice-select');
      const voiceOptions = voices.filter(v => v.lang.startsWith('vi') || v.lang.startsWith('en') || v.lang.startsWith('ko'))
        .map(v => `<option value="${v.voiceURI}">${v.name} (${v.lang})</option>`).join('');
      select.innerHTML = `<option value="auto">T·ª± ƒë·ªông</option>${voiceOptions}`;
      select.value = settings.voiceURI;
    }

    function speak(text, lang) {
        if (tts.speaking) tts.cancel();
        const u = new SpeechSynthesisUtterance(text);
        const langCode = { 'vi': 'vi-VN', 'en': 'en-US', 'ko': 'ko-KR' }[lang];
        u.lang = langCode;
        
        let voice = voices.find(v => v.voiceURI === settings.voiceURI) ||
                    voices.find(v => v.lang === langCode && v.default) ||
                    voices.find(v => v.lang === langCode);
        u.voice = voice;
        tts.speak(u);
    }
    
    main();

</script>
</body>
</html>


